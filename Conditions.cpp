#include "Conditions.h"




void lab1Conditions() {

	cout << "Лаба №1\n\n";
	cout << ">>> 1) Реализовать стандартные алгоритмы:\n     -линейного поиска;\n     -линейного поиска с использованием барьера;\n     -бинарного поиска(нерекурсивная и рекурсивная версии).\nПодсчитать количество производимых сравнений в целом и сравнений с \nэлементом массива отдельно в каждом методе для различных значений \nэлементов исходных массивах(из 100000000 элементов) :\n     -когда искомый элемент расположен первым;\n     -когда искомый элемент расположен последним;\n     -когда искомый элемент расположен в середине;\n     -когда искомого элемента нет.\n\n";
	cout << ">>> 2) Реализовать алгоритмы линейного поиска и линейного поиска с барьером для \nдвумерного массива.\n\n";
	cout << ">>> 3) Дан массив, элементы которого упорядочены по неубыванию значений и по \nстолбцам, и по строкам (считывайте массив из файла). Используя идею бинарного \nпоиска определить, есть ли в массиве элемент, равный x.\n\n";

}

void lab2Conditions() {

	cout << "Лаба №2\n\n";
	cout << ">>> 1) Реализовать алгоритмы: \n     -линейный поиск без использования логической переменной; \n     -алгоритм Бойера–Мура; \n     -алгоритм Кнута–Морриса–Пратта; \n     -алгоритм Карпа–Рабина.\nВсе 4 вида поиска должны содержать подсчет количества сравнений символов. Составить \nтаблицу, в которой выводится количество сравнений символов для 10 (можно больше, исходно \nхранить эти строки и подстроки в отдельном файле) различных примеров для \nкаждого из четырех алгоритмов. Примеры (строка и подстрока) придумывать таким образом, чтобы \nпоказать специфику алгоритмов – в каких случаях какой алгоритм эффективнее. После \nавтоматического запуска и заполнения таблицы каждый пример прокомментировать, выявив \nnособенности алгоритмов.\n\n";

}

void lab3Conditions() {

	cout << "Лаба №3\n\n";
	cout << ">>> 1) Имеется массив целых чисел a[1]...a[n], причем все числа неотрицательны и не \nпревосходят m. Отсортировать этот массив; число действий порядка m+n.\n\n";
	cout << ">>> 2) В массиве a[1]...a[n] целых чисел переставить элементы так, чтобы четные числа шли \nперед нечетными (не изменяя взаимный порядок в каждой из групп).\n\n";
	cout << ">>> 3) Подсчитать количество произведенных сравнений (отдельно рассмотреть сравнения с \nэлементом массива и все остальные) и количество произведенных перестановок \nэлементов (в некоторых случаях это изменение одного элемента массива, в некоторых \n– пары элементов) при сортировке по неубыванию массива из 100000 элементов, \nэлементы которого изначально расположены по неубыванию, по невозрастанию, \nслучайным образом. Методы сортировки: \n     -алгоритм простого выбора; \n     -алгоритм простого обмена; \n     -улучшенный алгоритм простого обмена(учет факта последнего обмена и его места); \n     -улучшенный алгоритм простого обмена – шейкер - сортировка(учет факта последнего обмена и чередование направлений просмотра элементов); \n     -алгоритм прямого включения(простыми вставками); \n     -улучшенный алгоритм прямого включения(добавить барьерный элемент); \n     -алгоритм сортировки слияниями; \n     -быстрая сортировка Хоара.\nЗаполнить таблицу автоматически.\n\n";

}

void lab4Conditions() {

	cout << "Лаба №4\n\n";
	cout << ">>> 1) Задача о расстановке ферзей на шахматном поле. \n     a)На шахматной доске N×N требуется найти один способ расстановки N ферзей, не \nатакующих друг друга, если он имеется. \n     б)На шахматной доске N×N требуется найти все способы расстановки N ферзей, не \nатакующих друг друга.\n\n";
	cout << ">>> 2) Расставить на доске N×N (N<=12) N ферзей так, чтобы наибольшее число ее полей \nоказалось вне боя ферзей. Ферзи при этом могут «бить» друг друга.\n\n";
	cout << ">>> 3) Определить, за какое наименьшее число ходов ферзь может обойти все поля доски N×N.\n\n";
	cout << ">>> 4) Расставить на доске N×N максимальное число ферзей так, чтобы каждый из них \nнападал ровно на р (р<=2) ферзей.\n\n";
	cout << ">>> 5) Задача об обходе конем шахматной доски. \n     a)Найти один способ обхода конем доски N×M. Конь должен побывать на каждой \nклетке доски только один раз. Начальная позиция коня определяется случайным \nобразом.Использовать правило Варнсдорфа. \n     б)Для каждого начального расположения коня найти количество способов обхода доски.\n\n";
	cout << ">>> 6) Магараджа – это фигура, которая объединяет в себе ходы коня и ферзя. Для доски \n10×10 найти способ расстановки 10 мирных магараджей.\n\n";
	cout << ">>> 7) Задача о коне Аттилы («Трава не растет там, где ступил мой конь!»). На шахматной \nдоске стоят белый конь и черный король. Некоторые поля доски считаются \n«горящими». Конь должен дойти до неприятельского короля, повергнуть его и \nвернуться на исходное место. При этом ему запрещено становиться как на горящие \nполя, так и на поля, которые уже пройдены.\n\n";

}

void lab5Conditions() {

	cout << "Лаба №5\n\n";
	cout << ">>> 1) Задача о лабиринте. Дано клеточное поле n*m, начальная и конечная клетки. Часть \nклеток занято препятствиями. За один ход можно перемещаться в одну из \nсвободных клеток по горизонтали или по вертикали. Найти кратчайший путь, если \nон существует, из начальной клетки в конечную клетку.\n\n";
	cout << ">>> 2) Задача о рюкзаке. Даны предметы n различных типов. Количество предметов \nкаждого типа не ограничено. Каждый предмет типа i имеет вес wi и стоимость vi, \ni=1,2, …n. Определить максимальную стоимость груза, вес которого не превышает W.\n\n";
	cout << ">>> 3) Задача о коммивояжере. Имеются n городов, расстояния между которыми заданы; \nкоммивояжеру необходимо выйти из какого-то города, посетить остальные n-1 \nгород точно по одному разу и вернуться в исходный город. При этом маршрут \nкоммивояжера должен быть минимальной длины (стоимости).\n\n";
	cout << ">>> 4) Судоку. Найти все способы решения головоломки «Судоку».\n\n";

}

void lab6Conditions() {

	cout << "Лаба №6\n\n";
	cout << ">>> 1) Черепашка находится в городе, все кварталы которого имеют прямоугольную \nформу и ей необходимо попасть с крайнего юго-восточного перекрестка на \nкрайний северо-западный. На некоторых улицах проводится ремонт и по ним \nзапрещено движение, стоимость проезда по остальным улицам задается. Кроме \nтого, для каждого перекрестка определена стоимость поворота. Найти для \nчерепашки маршрут минимальной стоимости.\nИсходные данные: \n     - N – количество перекрестков, определяется через 2 числа l, m и N = l * m(l < 11, m < 11);\n     - стоимость проезда и стоимость поворота на перекрестках – целые числа.\n\n";
	cout << ">>> 2) Реализовать классическую задачу о треугольнике. Натуральные числа выстроены в \nтреугольник. Разработать программу для поиска наибольшей возможной суммы при \nспуске от вершины треугольника к его основанию. Разрешенные перемещения: вниз \nвлево, вниз вправо.\n\n";
	cout << ">>> 3) Реализовать классическую задачу о степени числа. Даны два натуральных числа N и \nk. Требуется определить выражение, которое вычисляет kN. Разрешается \nиспользовать операции умножения и возведения в степень, круглые скобки и \nпеременную с именем k. Умножение считается одной операцией, возведению в \nстепень q соответствует q–1 операция. Найти минимальное количество операций, \nнеобходимое для возведения в степень N.\n\n";
	cout << ">>> 4) Реализовать классическую задачу о разбиении выпуклого N-угольника.\n\n";
	cout << ">>> 5) - \n\n";
	cout << ">>> 6) - \n\n";


}

void lab7Conditions() {

	cout << "Лаба №7\n\n";
	cout << "<Задачи отсутствуют>\n\n";

}
